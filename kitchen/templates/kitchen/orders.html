{% extends "menu/raw_base.html" %}
{% load static %}
{% block title %}
    Kitchen Orders
{% endblock title %}
{% block content %}
    <div class="container mt-3">
        <div class="top-actions d-flex flex-wrap gap-2 justify-content-center">
            <a href="{% url 'kitchen-orders' %}"
               class="btn btn-outline-dark btn-lg {% if request.resolver_match.url_name == 'kitchen-orders' %}active{% endif %}">
                Zamówienia
            </a>
            <a href="{% url 'available' %}"
               class="btn btn-outline-dark btn-lg {% if request.resolver_match.url_name == 'available' %}active{% endif %}">
                Zmień status
            </a>
        </div>
    </div>
    <div class="container-fluid p-0">
        <div class="container py-4">
            <h1 class="text-center text-dark mb-4">Kuchnia Zamówienia:</h1>
            <div id="orders-container" class="d-flex flex-wrap gap-3"></div>
        </div>
    </div>
    <audio id="notification-sound"
           src="{% static 'sounds/notification.mp3' %}"
           preload="auto"></audio>
    <style>
        /* Zwiększona czcionka dla całej sekcji zamówień */
        #orders-container {
            font-size: 1.2rem; /* Zwiększona czcionka */
        }
        /* Zwiększona szerokość kart i wyrównanie */
        .order-card {
            flex: 1 1 350px; /* min 350px, reszta dopasowana */
            max-width: 400px; /* Zwiększona szerokość */
        }
        .card-header h5 {
            font-size: 1.4rem; /* Zwiększony tytuł */
        }
        .list-group-item {
            font-size: 1.1rem; /* Zwiększona czcionka elementów listy */
        }
    </style>
    <script>
        const ordersContainer = document.getElementById('orders-container');
        const kitchenSocket = new WebSocket(
            'ws://' + window.location.host + '/ws/kitchen/orders/'
        );
        const pingInterval = 30000;

        function setupPing() {
            setInterval(() => {
                if (kitchenSocket.readyState === WebSocket.OPEN) {
                    kitchenSocket.send(JSON.stringify({
                        'action': 'ping'
                    }));
                    console.log('Ping sent to keep connection alive.');
                }
            }, pingInterval);
        }

        kitchenSocket.onopen = function(e) {
            console.log('WebSocket connection opened.');
            setupPing(); // Rozpocznij wysyłanie pingów po nawiązaniu połączenia
        };


        kitchenSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            console.log("Message received:", data);

            if (data.type === 'initial_orders') {
                ordersContainer.innerHTML = '';
                data.orders.forEach(order => {
                    addOrderToView(order);
                });
            } else if (data.type === 'new_order') {
                const order = data.order;
                addOrderToView(order);
                // add sound
                const sound = document.getElementById("notification-sound");
                if (sound) {
                    sound.play().catch(err => {
                        console.warn("Audio play blocked (autoplay policy):", err);
                    });
                }
            } else if (data.type === 'order_status_update') {
                const orderId = data.order_id;
                const newStatus = data.new_status;

                if (newStatus.toLowerCase() === 'ready') {
                    const orderElement = document.getElementById(`order-${orderId}`);
                    if (orderElement) {
                        orderElement.remove();
                        console.log(`Order ${orderId} has been removed.`);
                    }
                } else {
                    const statusSpan = document.getElementById(`status-${orderId}`);
                    if (statusSpan) {
                        statusSpan.innerText = newStatus;
                        statusSpan.className = `badge bg-${getStatusClass(newStatus)}`;
                    }
                }
            }
        };

        kitchenSocket.onclose = function(e) {
            console.error('Kitchen socket closed unexpectedly');
        };

        function getStatusClass(status) {
            switch (status.toLowerCase()) {
                case 'ordering':
                    return 'primary';
                case 'preparing':
                    return 'warning text-dark';
                case 'ready':
                    return 'success';
                default:
                    return 'secondary';
            }
        }

        function changeStatus(orderId, status) {
            kitchenSocket.send(JSON.stringify({
                'action': status,
                'order_id': orderId
            }));
        }

        function addOrderToView(order) {
            if (document.getElementById(`order-${order.id}`)) return;

            let orderItemsHtml = '';
            order.order_items.forEach(item => {
                // Nowa linia: Ustalenie klas CSS na podstawie is_done
                const doneClass = item.is_done ? 'text-decoration-line-through text-muted' : '';

                orderItemsHtml += `
                    <li class="list-group-item ${doneClass}" id="order-${order.id}-item-${item.id}" onclick="toggleItemDone(${order.id}, ${item.id}, '${order.sender}')">
                        ${item.name_snapshot} ×${item.quantity}
                        ${item.note ? `<small class="text-muted">(${item.note})</small>` : ''}
                    </li>
                `;
            });

            const orderElement = document.createElement('div');
            orderElement.id = `order-${order.id}`;
            orderElement.className = 'card mb-3 shadow-sm order-card';

            const statusClass = getStatusClass(order.status);

            orderElement.innerHTML = `
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Order #${order.id} @${order.sender}</h5>
                    <span id="status-${order.id}" class="badge bg-${statusClass}">${order.status}</span>
                </div>
                <div class="card-body">
                    <p class="mb-1"><strong>Stół:</strong> ${order.table}</p>
                    <p class="mb-2">
                        <strong>Czas oczekiwania:</strong>
                        <span class="waiting-time" data-created-at="${order.created_at}" id="waiting-${order.id}">0m 0s</span>
                    </p>
                    <ul class="list-group mb-3">${orderItemsHtml}</ul>
                    <div class="d-flex gap-2">
                        <button class="btn btn-warning text-dark" onclick="changeStatus(${order.id}, 'preparing')">Preparing</button>
                        <button class="btn btn-success" onclick="changeStatus(${order.id}, 'ready')">Ready</button>
                    </div>
                </div>
            `;

            ordersContainer.append(orderElement);
        }

        function toggleItemDone(orderId, itemId, senderUsername) {
            const el = document.getElementById(`order-${orderId}-item-${itemId}`);
            el.classList.toggle('text-decoration-line-through');
            el.classList.toggle('text-muted');

            kitchenSocket.send(JSON.stringify({
                action: 'item_done',
                order_id: orderId,
                item_id: itemId,
                username: senderUsername
            }));
        }
        function updateWaitingTimes() {
            document.querySelectorAll('.waiting-time').forEach(span => {
                const createdAt = new Date(span.dataset.createdAt); // parsujemy timestamp
                const now = new Date();
                const diffMs = now - createdAt;
                const diffSec = Math.floor(diffMs / 1000);

                const minutes = Math.floor(diffSec / 60);
                const seconds = diffSec % 60;

                span.textContent = `${minutes}m ${seconds}s`;
            });
        }

        // aktualizuj co 1 sek
        setInterval(updateWaitingTimes, 1000);

    </script>
{% endblock content %}
